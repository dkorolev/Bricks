#ifndef CURRENT_DOUBLE_REPRESENTATION_TEST
#error "Must `#define` `CURRENT_DOUBLE_REPRESENTATION_TEST` before `#include`-ing `double_values.inl`."
#endif

// clang-format off
CURRENT_DOUBLE_REPRESENTATION_TEST(0x0000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000, +0.000000, +0x0p+0, true, +0.0, "+0.0")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x8000000000000000, 0b1000000000000000000000000000000000000000000000000000000000000000, -0.000000, -0x0p+0, true, -0.0, "-0.0")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3ff0000000000000, 0b0011111111110000000000000000000000000000000000000000000000000000, +1.000000, +0x1p+0, true, +1.0, "+1.0")
CURRENT_DOUBLE_REPRESENTATION_TEST(0xbff0000000000000, 0b1011111111110000000000000000000000000000000000000000000000000000, -1.000000, -0x1p+0, true, -1.0, "-1.0")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3fe0000000000000, 0b0011111111100000000000000000000000000000000000000000000000000000, +0.500000, +0x1p-1, true, +0.5, "+0.5")
CURRENT_DOUBLE_REPRESENTATION_TEST(0xbfe0000000000000, 0b1011111111100000000000000000000000000000000000000000000000000000, -0.500000, -0x1p-1, true, -0.5, "-0.5")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x4004000000000000, 0b0100000000000100000000000000000000000000000000000000000000000000, +2.500000, +0x1.4p+1, true, +2.5, "+2.5")
CURRENT_DOUBLE_REPRESENTATION_TEST(0xc004000000000000, 0b1100000000000100000000000000000000000000000000000000000000000000, -2.500000, -0x1.4p+1, true, -2.5, "-2.5")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x4202a05f20000000, 0b0100001000000010101000000101111100100000000000000000000000000000, +10000000000.000000, +0x1.2a05f2p+33, true, +1e10, "+1e10")
CURRENT_DOUBLE_REPRESENTATION_TEST(0xc202a05f20000000, 0b1100001000000010101000000101111100100000000000000000000000000000, -10000000000.000000, -0x1.2a05f2p+33, true, -1e10, "-1e10")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3ddb7cdfd9d7bdbb, 0b0011110111011011011111001101111111011001110101111011110110111011, +0.000000, +0x1.b7cdfd9d7bdbbp-34, true, +1e-10, "+1e-10")
CURRENT_DOUBLE_REPRESENTATION_TEST(0xbddb7cdfd9d7bdbb, 0b1011110111011011011111001101111111011001110101111011110110111011, -0.000000, -0x1.b7cdfd9d7bdbbp-34, true, -1e-10, "-1e-10")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x4415af1d78b58c40, 0b0100010000010101101011110001110101111000101101011000110001000000, +100000000000000000000.000000, +0x1.5af1d78b58c4p+66, true, +1e20, "+1e20")
CURRENT_DOUBLE_REPRESENTATION_TEST(0xc415af1d78b58c40, 0b1100010000010101101011110001110101111000101101011000110001000000, -100000000000000000000.000000, -0x1.5af1d78b58c4p+66, true, -1e20, "-1e20")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3ff6a09e667f3bcd, 0b0011111111110110101000001001111001100110011111110011101111001101, +1.414214, +0x1.6a09e667f3bcdp+0, true, sqrt(2.0), "sqrt(2.0)")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3ffbb67ae8584caa, 0b0011111111111011101101100111101011101000010110000100110010101010, +1.732051, +0x1.bb67ae8584caap+0, true, sqrt(3.0), "sqrt(3.0)")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x4005bf0a8b145769, 0b0100000000000101101111110000101010001011000101000101011101101001, +2.718282, +0x1.5bf0a8b145769p+1, true, exp(1.0), "exp(1.0)")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3fe62e42fefa39ef, 0b0011111111100110001011100100001011111110111110100011100111101111, +0.693147, +0x1.62e42fefa39efp-1, true, log(2.0), "log(2.0)")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x400921fb54442d18, 0b0100000000001001001000011111101101010100010001000010110100011000, +3.141593, +0x1.921fb54442d18p+1, true, M_PI, "M_PI")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3feaed548f090cee, 0b0011111111101010111011010101010010001111000010010000110011101110, +0.841471, +0x1.aed548f090ceep-1, true, sin(1.0), "sin(1.0)")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3fe14a280fb5068c, 0b0011111111100001010010100010100000001111101101010000011010001100, +0.540302, +0x1.14a280fb5068cp-1, true, cos(1.0), "cos(1.0)")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3ff8eb245cbee3a6, 0b0011111111111000111010110010010001011100101111101110001110100110, +1.557408, +0x1.8eb245cbee3a6p+0, true, tan(1.0), "tan(1.0)")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3fe0c152382d7366, 0b0011111111100000110000010101001000111000001011010111001101100110, +0.523599, +0x1.0c152382d7366p-1, true, asin(0.5), "asin(0.5)")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3ff0c152382d7366, 0b0011111111110000110000010101001000111000001011010111001101100110, +1.047198, +0x1.0c152382d7366p+0, true, acos(0.5), "acos(0.5)")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x3fddac670561bb4f, 0b0011111111011101101011000110011100000101011000011011101101001111, +0.463648, +0x1.dac670561bb4fp-2, true, atan(0.5), "atan(0.5)")
CURRENT_DOUBLE_REPRESENTATION_TEST(0x54b249ad2594c37d, 0b0101010010110010010010011010110100100101100101001100001101111101, +10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.000000, +0x1.249ad2594c37dp+332, false, +1e100, "+1e100")
CURRENT_DOUBLE_REPRESENTATION_TEST(0xd4b249ad2594c37d, 0b1101010010110010010010011010110100100101100101001100001101111101, -10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.000000, -0x1.249ad2594c37dp+332, false, -1e100, "-1e100")
// clang-format on

// NOTE(dkorolev): Here is the code to generate the above.

#if 0
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <string>
#include <vector>

inline void gen(double value_double, bool compactifiable, char const *source) {
  uint64_t const value_uint64_t = *reinterpret_cast<uint64_t *>(&value_double);
  uint64_t tmp = value_uint64_t;
  std::string binary_representation;
  for (size_t i = 0; i < 64; ++i) {
    binary_representation += '0' + (tmp & 1);
    tmp >>= 1;
  }
  std::reverse(std::begin(binary_representation), std::end(binary_representation));

  printf("CURRENT_DOUBLE_REPRESENTATION_TEST(0x%016lx, 0b%s, %+lf, %+la, %s, %s, \"%s\")\n",
         value_uint64_t,
         binary_representation.c_str(),
         value_double,
         value_double,
         compactifiable ? "true" : "false",
         source,
         source);
}

#define GEN(value, compactifiable) gen(value, compactifiable, #value)

int main() {
  GEN(+0.0, true);
  GEN(-0.0, true);
  GEN(+1.0, true);
  GEN(-1.0, true);
  GEN(+0.5, true);
  GEN(-0.5, true);
  GEN(+2.5, true);
  GEN(-2.5, true);
  GEN(+1e10, true);
  GEN(-1e10, true);
  GEN(+1e-10, true);
  GEN(-1e-10, true);
  GEN(+1e20, true);
  GEN(-1e20, true);
  GEN(sqrt(2.0), true);
  GEN(sqrt(3.0), true);
  GEN(exp(1.0), true);
  GEN(log(2.0), true);
  GEN(M_PI, true);
  GEN(sin(1.0), true);
  GEN(cos(1.0), true);
  GEN(tan(1.0), true);
  GEN(asin(0.5), true);
  GEN(acos(0.5), true);
  GEN(atan(0.5), true);
  GEN(+1e100, false);  // not yet an inf, but already is not compactifiable.
  GEN(-1e100, false);  // not yet an inf, but already is not compactifiable.
}
#endif
